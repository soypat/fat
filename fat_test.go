package fat

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"log/slog"
	"os"
	"testing"
)

func TestForEachFile(t *testing.T) {
	fs, _ := initTestFAT()
	var dir Dir
	err := fs.OpenDir(&dir, "/")
	if err != nil {
		t.Fatal(err)
	}
	i := 0
	err = dir.ForEachFile(func(fi *FileInfo) error {
		i++
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
	if i != 2 {
		t.Errorf("unexpected number of files: %d", i)

	}
}

func TestWriteNew(t *testing.T) {
	const filename = "deaconblues"
	const writeData = "\nnew data\n"
	fs, _ := initTestFAT()
	var fp File
	fr := fs.f_open(&fp, filename, faWrite|faCreateNew)
	mustBeOK(t, fr)

	n, fr := fp.f_write([]byte(writeData))
	mustBeOK(t, fr)
	if n != len(writeData) {
		t.Errorf("short write: %d != %d", n, len(writeData))
	}

	fr = fp.f_close()
	mustBeOK(t, fr)

	// Read back data.
	fr = fs.f_open(&fp, filename, faRead)
	mustBeOK(t, fr)
	buf := make([]byte, len(writeData)+20)
	n, fr = fp.f_read(buf)
	mustBeOK(t, fr)
	got := string(buf[:n])
	if got != writeData {
		t.Errorf("mismatched contents:\n%q\n%q\n", got, writeData)
	}
}

func TestWriteExisting(t *testing.T) {
	const filename = "rootfile"
	const newData = "\nnew data\n"
	fs, _ := initTestFAT()
	var rootFile File
	fr := fs.f_open(&rootFile, filename, faWrite)
	mustBeOK(t, fr)

	n, fr := rootFile.f_write([]byte(newData))
	mustBeOK(t, fr)
	if n != len(newData) {
		t.Errorf("short write: %d != %d", n, len(newData))
	}

	// Sync changes.
	fr = rootFile.f_close()
	mustBeOK(t, fr)

	// Read back data.
	fr = fs.f_open(&rootFile, filename, faRead)
	mustBeOK(t, fr)
	buf := make([]byte, len(rootFileContents)+len(newData)+20)
	n, fr = rootFile.f_read(buf)
	mustBeOK(t, fr)
	got := string(buf[:n])
	want := newData + rootFileContents[len(newData):]
	if got != want {
		t.Errorf("mismatched contents:\n%q\n%q\n", got, want)
	}
}

func TestWriteAppend(t *testing.T) {
	const filename = "rootfile"
	const newData = "\nnew data\n"
	fs, _ := initTestFAT()
	var rootFile File
	fr := fs.f_open(&rootFile, filename, faWrite|faOpenAppend)
	mustBeOK(t, fr)

	n, fr := rootFile.f_write([]byte(newData))
	mustBeOK(t, fr)
	if n != len(newData) {
		t.Errorf("short write: %d != %d", n, len(newData))
	}

	// Sync changes.
	fr = rootFile.f_close()
	mustBeOK(t, fr)

	// Read back data.
	fr = fs.f_open(&rootFile, filename, faRead)
	mustBeOK(t, fr)
	buf := make([]byte, len(rootFileContents)+len(newData)+20)
	n, fr = rootFile.f_read(buf)
	mustBeOK(t, fr)
	got := string(buf[:n])
	want := rootFileContents + newData
	if got != want {
		t.Errorf("mismatched contents:\n%q\n%q\n", got, want)
	}
}

func TestRead(t *testing.T) {
	fs, _ := initTestFAT()
	var rootFile File
	fr := fs.f_open(&rootFile, "rootfile", faRead)
	mustBeOK(t, fr)

	buf := make([]byte, 512)
	n, fr := rootFile.f_read(buf)
	mustBeOK(t, fr)

	got := string(buf[:n])
	if got != rootFileContents {
		t.Errorf("mismatched rootfile contents:\n%q\n%q\n", got, rootFileContents)
	}

	var dirfile File
	fr = fs.f_open(&dirfile, "rootdir/dirfile", faRead)
	mustBeOK(t, fr)
	n, fr = dirfile.f_read(buf)
	mustBeOK(t, fr)
	got = string(buf[:n])
	if got != dirFileContents {
		t.Errorf("mismatched dirfile contents:\n%q\n%q\n", got, dirFileContents)
	}
}

func TestFileInfo(t *testing.T) {
	fs, _ := initTestFAT()
	var dir dir
	fr := fs.f_opendir(&dir, "rootdir")
	mustBeOK(t, fr)
	var finfo FileInfo
	fr = dir.f_readdir(&finfo)
	if fr != frOK {
		t.Fatal(fr.Error())
	}
	name := finfo.Name()
	if name != "dirfile" {
		t.Errorf("mismatched name %q", name)
	}
	alt := finfo.AlternateName()
	if alt != "DIRFILE" {
		t.Errorf("mismatched alternate name: %q", alt)
	}
}

func DefaultFATByteBlocks(numBlocks int) BlockDeviceExtended {
	// TODO: try BlockMap implementation with tests to see perf improvements?
	// newfat := maps.Clone(fatInit)
	// blk := &BlockMap{data: newfat}
	// return blk
	const defaultBlockSize = 512
	blk, _ := makeBlockIndexer(defaultBlockSize)
	buf := make([]byte, defaultBlockSize*numBlocks)
	for i, b := range fatInit {
		off := i * defaultBlockSize
		if off >= int64(len(buf)) {
			panic(fmt.Sprintf("fatInit[%d] out of range", i))
		}
		copy(buf[off:], b[:])
	}
	return &BlockByteSlice{
		blk: blk,
		buf: buf,
	}
}
func mustBeOK(t *testing.T, fr fileResult) {
	t.Helper()
	if fr != frOK {
		t.Fatalf("FR%d: %s", fr, fr.Error())
	}
}

func fatInitDiff(data []byte) (s string) {
	max := int64(len(data)) / 512
	for block := int64(0); block < max; block++ {
		b := data[block*512 : (block+1)*512]
		expect := fatInit[block]
		if !bytes.Equal(b, expect[:]) {
			s += fmt.Sprintf("block %d got!=want:\n%s\n%s\n", block, hex.Dump(b), hex.Dump(expect[:]))
		}
	}
	if len(s) == 0 {
		return "no differences"
	}
	return s
}

func initTestFAT() (*FS, BlockDeviceExtended) {
	return initTestFATWithLogger(32000, slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slogLevelTrace,
	})))

}
func initTestFATWithLogger(size int64, log *slog.Logger) (*FS, BlockDeviceExtended) {
	dev := DefaultFATByteBlocks(int(size))
	var fs FS
	fs.log = log
	ss := uint16(dev.BlockSize())
	err := fs.Mount(dev, int(ss), ModeRW)
	if err != nil {
		panic(err)
	}
	return &fs, dev
}

// Start of clean slate FAT32 filesystem image with name `keylargo`, 8GB in size.
// Contains a folder structure with a rootfile with some test, a rootdir directory
// with a file in it.
var fatInit = map[int64][512]byte{
	// Boot sector.
	0: {0xeb, 0x58, 0x90, 0x6d, 0x6b, 0x66, 0x73, 0x2e, 0x66, 0x61, 0x74, 0x00, 0x02, 0x08, 0x20, 0x00, // |.X.mkfs.fat... .|
		0x02, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x3e, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, // |........>.......|
		0xd0, 0x07, 0xf0, 0x00, 0xe8, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // |.....;..........|
		0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // |................|
		0x80, 0x00, 0x29, 0x06, 0xf1, 0x12, 0xc5, 0x6b, 0x65, 0x79, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x20, // |..)....keylargo |
		0x20, 0x20, 0x46, 0x41, 0x54, 0x33, 0x32, 0x20, 0x20, 0x20, 0x0e, 0x1f, 0xbe, 0x77, 0x7c, 0xac, // |  FAT32   ...w|.|
		0x22, 0xc0, 0x74, 0x0b, 0x56, 0xb4, 0x0e, 0xbb, 0x07, 0x00, 0xcd, 0x10, 0x5e, 0xeb, 0xf0, 0x32, // |".t.V.......^..2|
		0xe4, 0xcd, 0x16, 0xcd, 0x19, 0xeb, 0xfe, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, // |.......This is n|
		0x6f, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x64, 0x69, // |ot a bootable di|
		0x73, 0x6b, 0x2e, 0x20, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x69, 0x6e, 0x73, 0x65, // |sk.  Please inse|
		0x72, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x6c, // |rt a bootable fl|
		0x6f, 0x70, 0x70, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x0d, 0x0a, 0x70, 0x72, 0x65, 0x73, 0x73, 0x20, // |oppy and..press |
		0x61, 0x6e, 0x79, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x72, 0x79, 0x20, 0x61, // |any key to try a|
		0x67, 0x61, 0x69, 0x6e, 0x20, 0x2e, 0x2e, 0x2e, 0x20, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, // |gain ... .......|
		510: 0x55, 0xaa,
	},

	1: {0: 0x52, 0x52, 0x61, 0x41,
		484: 0x72, 0x72, 0x41, 0x61, 0xf8, 0xf1, 0x1d, 0x00, 0x05,
		510: 0x55, 0xaa},

	6: {0xeb, 0x58, 0x90, 0x6d, 0x6b, 0x66, 0x73, 0x2e, 0x66, 0x61, 0x74, 0x00, 0x02, 0x08, 0x20, 0x00, // |.X.mkfs.fat... .|
		0x02, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x3e, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, // |........>.......|
		0xd0, 0x07, 0xf0, 0x00, 0xe8, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // |.....;..........|
		0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // |................|
		0x80, 0x00, 0x29, 0x06, 0xf1, 0x12, 0xc5, 0x6b, 0x65, 0x79, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x20, // |..)....keylargo |
		0x20, 0x20, 0x46, 0x41, 0x54, 0x33, 0x32, 0x20, 0x20, 0x20, 0x0e, 0x1f, 0xbe, 0x77, 0x7c, 0xac, // |  FAT32   ...w|.|
		0x22, 0xc0, 0x74, 0x0b, 0x56, 0xb4, 0x0e, 0xbb, 0x07, 0x00, 0xcd, 0x10, 0x5e, 0xeb, 0xf0, 0x32, // |".t.V.......^..2|
		0xe4, 0xcd, 0x16, 0xcd, 0x19, 0xeb, 0xfe, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, // |.......This is n|
		0x6f, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x64, 0x69, // |ot a bootable di|
		0x73, 0x6b, 0x2e, 0x20, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x69, 0x6e, 0x73, 0x65, // |sk.  Please inse|
		0x72, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x6c, // |rt a bootable fl|
		0x6f, 0x70, 0x70, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x0d, 0x0a, 0x70, 0x72, 0x65, 0x73, 0x73, 0x20, // |oppy and..press |
		0x61, 0x6e, 0x79, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x72, 0x79, 0x20, 0x61, // |any key to try a|
		0x67, 0x61, 0x69, 0x6e, 0x20, 0x2e, 0x2e, 0x2e, 0x20, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, // |gain ... .......|
		510: 0x55, 0xaa,
	},

	7: {0: 0x52, 0x52, 0x61, 0x41,
		484: 0x72, 0x72, 0x41, 0x61, 0xfb, 0xf1, 0x1d, 0x00, 0x02,
		510: 0x55, 0xaa},

	// Below is the FAT.
	32: {
		0xf8, 0xff, 0xff, 0x0f, // EOC
		0xff, 0xff, 0xff, 0x0f,
		0xf8, 0xff, 0xff, 0x0f,
		0xff, 0xff, 0xff, 0x0f,
		0xff, 0xff, 0xff, 0x0f,
		0xff, 0xff, 0xff, 0x0f,
	},
	// FAT copy for redundancy. Same as above.
	15368: {0xf8, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f},

	30704: { // Root directory contents.
		0x6b, 0x65, 0x79, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x20, 0x20, 0x20, 0x08, 0x00, 0x00, 0xba, 0x53, // |keylargo   ....S|
		0x35, 0x58, 0x35, 0x58, 0x00, 0x00, 0xba, 0x53, 0x35, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // |5X5X...S5X......|
		0x41, 0x72, 0x00, 0x6f, 0x00, 0x6f, 0x00, 0x74, 0x00, 0x66, 0x00, 0x0f, 0x00, 0x1a, 0x69, 0x00, // |Ar.o.o.t.f....i.|
		0x6c, 0x00, 0x65, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, // |l.e.............|
		0x52, 0x4f, 0x4f, 0x54, 0x46, 0x49, 0x4c, 0x45, 0x20, 0x20, 0x20, 0x20, 0x00, 0x03, 0xd4, 0xbb, // |ROOTFILE    ....|
		0x37, 0x58, 0x37, 0x58, 0x00, 0x00, 0xd4, 0xbb, 0x37, 0x58, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00, // |7X7X....7X......|
		0x41, 0x72, 0x00, 0x6f, 0x00, 0x6f, 0x00, 0x74, 0x00, 0x64, 0x00, 0x0f, 0x00, 0xde, 0x69, 0x00, // |Ar.o.o.t.d....i.|
		0x72, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, // |r...............|
		0x52, 0x4f, 0x4f, 0x54, 0x44, 0x49, 0x52, 0x20, 0x20, 0x20, 0x20, 0x10, 0x00, 0x29, 0xe4, 0xbb, // |ROOTDIR    ..)..|
		0x37, 0x58, 0x37, 0x58, 0x00, 0x00, 0xe4, 0xbb, 0x37, 0x58, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, // |7X7X....7X......|
		0xe5, 0x6d, 0x00, 0x2d, 0x00, 0x4e, 0x00, 0x44, 0x00, 0x38, 0x00, 0x0f, 0x00, 0x95, 0x4a, 0x00, // |.m.-.N.D.8....J.|
		0x49, 0x00, 0x32, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, // |I.2.............|
		0xe5, 0x2e, 0x00, 0x67, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00, 0x0f, 0x00, 0x95, 0x70, 0x00, // |...g.o.u.t....p.|
		0x75, 0x00, 0x74, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00, 0x00, 0x00, 0x65, 0x00, 0x61, 0x00, // |u.t.s.t.r...e.a.|
		0xe5, 0x4f, 0x55, 0x54, 0x50, 0x55, 0x7e, 0x31, 0x20, 0x20, 0x20, 0x20, 0x00, 0x03, 0xd4, 0xbb, // |.OUTPU~1    ....|
		0x37, 0x58, 0x37, 0x58, 0x00, 0x00, 0xd4, 0xbb, 0x37, 0x58, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00, // |7X7X....7X......|
	},

	30712: { // Root subdirectory "rootdir" contents.
		0x2e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x00, 0x28, 0x64, 0xb6, // |.          ..(d.|
		0x37, 0x58, 0x37, 0x58, 0x00, 0x00, 0x64, 0xb6, 0x37, 0x58, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, // |7X7X..d.7X......|
		0x2e, 0x2e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x00, 0x28, 0x64, 0xb6, // |..         ..(d.|
		0x37, 0x58, 0x37, 0x58, 0x00, 0x00, 0x64, 0xb6, 0x37, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // |7X7X..d.7X......|
		0x41, 0x64, 0x00, 0x69, 0x00, 0x72, 0x00, 0x66, 0x00, 0x69, 0x00, 0x0f, 0x00, 0x27, 0x6c, 0x00, // |Ad.i.r.f.i...'l.|
		0x65, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, // |e...............|
		0x44, 0x49, 0x52, 0x46, 0x49, 0x4c, 0x45, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x28, 0xe4, 0xbb, // |DIRFILE     .(..|
		0x37, 0x58, 0x37, 0x58, 0x00, 0x00, 0xe4, 0xbb, 0x37, 0x58, 0x05, 0x00, 0x49, 0x00, 0x00, 0x00, // |7X7X....7X..I...|
		0xe5, 0x6d, 0x00, 0x2d, 0x00, 0x48, 0x00, 0x49, 0x00, 0x47, 0x00, 0x0f, 0x00, 0x95, 0x37, 0x00, // |.m.-.H.I.G....7.|
		0x48, 0x00, 0x32, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, // |H.2.............|
		0xe5, 0x2e, 0x00, 0x67, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00, 0x0f, 0x00, 0x95, 0x70, 0x00, // |...g.o.u.t....p.|
		0x75, 0x00, 0x74, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00, 0x00, 0x00, 0x65, 0x00, 0x61, 0x00, // |u.t.s.t.r...e.a.|
		0xe5, 0x4f, 0x55, 0x54, 0x50, 0x55, 0x7e, 0x31, 0x20, 0x20, 0x20, 0x20, 0x00, 0x28, 0xe4, 0xbb, // |.OUTPU~1    .(..|
		0x37, 0x58, 0x37, 0x58, 0x00, 0x00, 0xe4, 0xbb, 0x37, 0x58, 0x05, 0x00, 0x49, 0x00, 0x00, 0x00, // |7X7X....7X..I...|
	},

	// Below are file contents.

	// Says: "This is\nthe rootfile"
	30720: {0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x0a, 0x74, 0x68, 0x65, 0x20, 0x72, 0x6f, 0x6f, 0x74, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x0a},
	30728: {
		0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x0a, 0x6e, 0x6f, 0x74, 0x20, // |this is not.not |
		0x74, 0x68, 0x65, 0x20, 0x72, 0x6f, 0x6f, 0x74, 0x0a, 0x6e, 0x6f, 0x74, 0x20, 0x74, 0x68, 0x65, // |the roo7t.not the
		0x20, 0x72, 0x6f, 0x6f, 0x74, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x0a, 0x6e, 0x6f, 0x70, 0x65, 0x2e, // | root file.nope.|
		0x20, 0x0a, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, // | .This file has |
		0x35, 0x20, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x2e, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // |5 lines.........|
	},
}

const rootFileContents = "this is\nthe root file\n"
const dirFileContents = "this is not\nnot the root\nnot the root file\nnope. \nThis file has 5 lines.\n"

func TestBootSector(t *testing.T) {
	// Print out the boot sector data.
	dat := fatInit[0]
	bs := biosParamBlock{data: dat[:]}
	fsiLBA := bs.FSInfo()
	fatLBA := 0 + bs.ReservedSectors()
	fatSz := bs.SectorsPerFAT() * uint32(bs.SectorSize())
	t.Log(bs.String())

	// Print out the FSInfo sector data.
	datfsi := fatInit[int64(fsiLBA)]
	fsi := fsinfoSector{data: datfsi[:]}
	t.Log(fsi.String())

	// Print out the FAT.
	datFAT := fatInit[int64(fatLBA)]
	fat := fat32Sector{data: datFAT[:]}
	t.Log(fat.String())
	_ = fatSz

}
